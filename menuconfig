/**
 * @file MenuConfig.h
 * @brief Configuración del menú para el control de parámetros mediante LiquidMenu.
 */

#ifndef MENUCONFIG_H
#define MENUCONFIG_H

#include "variables.h"
#include <LiquidMenu.h>

// Definición de las líneas del menú con sus respectivos parámetros.
LiquidLine line1(0, 1, "TEMP HIGH [", maxTemp, "]");
LiquidLine line2(0, 1, "TEMP LOW [", minTemp, "]");
LiquidLine line3(0, 1, "LUZ HIGH [", maxLight, "]");
LiquidLine line4(0, 1, "LUZ LOW [", minLight, "]");
LiquidLine line5(0, 1, "HALL [", maxHall, "]");
LiquidLine line6(0, 1, "RESET");

// Definición de la pantalla y el menú.
LiquidScreen screen;
LiquidMenu menu(lcd);

/**
 * @brief Función en blanco utilizada para hacer las líneas enfocables.
 */
void blankFunction() {
    return;
}

/**
 * @brief Sube los valores de las variables dependiendo de la línea actual.
 * 
 * @param actualLine Línea actual seleccionada.
 */
void upValue(int actualLine);

/**
 * @brief Baja los valores de las variables dependiendo de la línea actual.
 * 
 * @param actualLine Línea actual seleccionada.
 */
void downValue(int actualLine);

/**
 * @brief Inicializa y configura el menú LiquidMenu.
 */
void startLiquidMenu() {
  screen.add_line(line1);
  screen.add_line(line2);
  screen.add_line(line3);
  screen.add_line(line4);
  screen.add_line(line5);
  screen.add_line(line6);

  line1.attach_function(1, blankFunction);
  line2.attach_function(1, blankFunction);
  line3.attach_function(1, blankFunction);
  line4.attach_function(1, blankFunction);
  line5.attach_function(1, blankFunction);
  line6.attach_function(1, blankFunction);

  screen.set_displayLineCount(2);

  line1.set_decimalPlaces(2);

  menu.add_screen(screen);

  menu.update();
  menu.switch_focus();

  taskLoopMenu.Start();
}

/**
 * @brief Función de bucle para actualizar el menú y gestionar entradas del teclado.
 */
void loopLiquidMenu() {
  char key = keypad.getKey();

  menu.update();
  if(!key)
    return;

  int actualLine = menu.get_focusedLine();

  switch (key) {
  case 'A':
    upValue(actualLine);
    break;
  case 'B':
    downValue(actualLine);
    break;
  case 'D':
    menu.switch_focus();
    if(actualLine == 5)
      menu.switch_focus();
    break;
  default:
    Serial.println(actualLine);
  break;
  }
}

/**
 * @brief Resetea los valores de las variables a sus valores predeterminados.
 */
void reset() {
  maxTemp = 40;
  minTemp = 0;
  maxLight= 300;
  minLight= 0;
  maxHall = 1000;  
}

/**
 * @brief Sube el valor de la variable correspondiente a la línea actual.
 * 
 * @param actualLine Línea actual seleccionada.
 */
void upValue(int actualLine) {
  switch (actualLine) {
  case 0:
    maxTemp += 2;
    break;
  case 1:
    if(minTemp + 2 < maxTemp)
      minTemp += 2; 
    break;
  case 2:
    maxLight += 20;
    break;
  case 3:
    if(minLight + 20 < maxLight)
      minLight += 20;
    break;
  case 4:
    maxHall += 50;
    break;
  case 5:
    reset();
    break;
  }
}

/**
 * @brief Baja el valor de la variable correspondiente a la línea actual.
 * 
 * @param actualLine Línea actual seleccionada.
 */
void downValue(int actualLine) {
  switch (actualLine) {
  case 0:
    if(maxTemp - 2 > minTemp)
      maxTemp -= 2;
    break;
  case 1:
    minTemp -= 2; 
    break;
  case 2:
    if(maxLight - 20 > minLight)
      maxLight -= 20;
    break;
  case 3:
    minLight -= 20;
    break;
  case 4:
    maxHall -= 50;
    break;
  case 5:
    reset();
    break;
  }
}

#endif
